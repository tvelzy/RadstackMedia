<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="board.messageedit.alreadyrated" xml:space="preserve">
    <value>You've already rated.</value>
  </data>
  <data name="doctype.ecommerce.mappingwarning" xml:space="preserve">
    <value>These settings provide backward compatibility after upgrading or importing from older versions.&lt;/br&gt; It is not necessary to use mapping in current version of CMS.</value>
  </data>
  <data name="general.actionfinished" xml:space="preserve">
    <value>Action finished successfully</value>
  </data>
  <data name="general.copyfiles.precompiled" xml:space="preserve">
    <value>Cannot copy physical files in precompiled website.</value>
  </data>
  <data name="macros.refreshsecurityparams" xml:space="preserve">
    <value>Update macro signatures</value>
  </data>
  <data name="macros.refreshsecurityparams.currentsaltisconnectionstring" xml:space="preserve">
    <value>(Current salt is a connection string, not shown for security reasons)</value>
  </data>
  <data name="macros.refreshsecurityparams.currentsaltiscustomvalue" xml:space="preserve">
    <value>(Current salt is a custom value, not shown for security reasons)</value>
  </data>
  <data name="macros.refreshsecurityparams.description" xml:space="preserve">
    <value>Whenever a user saves a macro expression, the system automatically adds a security signature containing the user name of the macro's author and a hash of the expression. The hash function also appends a &lt;strong&gt;salt&lt;/strong&gt; to the input. By default, the system uses the application's database connection string as the salt. 
&lt;br /&gt;&lt;br /&gt;
If your application's hash salt value changes, the security signatures of existing macro expressions become invalid. This may lead to problems with unresolved macros in certain scenarios:
&lt;ul&gt;
&lt;li&gt;
The connection string of your application has changed, e.g. when moving to a different server or after setting a new database password.
&lt;/li&gt;&lt;li&gt;
You are using content staging to transfer data containing macros to another instance with a different connection string.
&lt;/li&gt;&lt;li&gt;
You have set a new custom salt via the &lt;strong&gt;CMSHashStringSalt&lt;/strong&gt; web.config key.
&lt;/li&gt;&lt;/ul&gt;
To re-sign all occurrences of macros in the system, enter the appropriate hash salt values and click &lt;strong&gt;Update macro signatures&lt;/strong&gt;.</value>
  </data>
  <data name="macros.refreshsecurityparams.newsalt" xml:space="preserve">
    <value>New salt</value>
  </data>
  <data name="macros.refreshsecurityparams.newsaltempty" xml:space="preserve">
    <value>Please enter the new salt.</value>
  </data>
  <data name="macros.refreshsecurityparams.oldsalt" xml:space="preserve">
    <value>Old salt</value>
  </data>
  <data name="macros.refreshsecurityparams.oldsaltempty" xml:space="preserve">
    <value>Please enter the old salt.</value>
  </data>
  <data name="macros.refreshsecurityparams.processing" xml:space="preserve">
    <value>Processing '{0}' objects ...</value>
  </data>
  <data name="macros.refreshsecurityparams.refreshall" xml:space="preserve">
    <value>Sign all macros</value>
  </data>
  <data name="macros.refreshsecurityparams.refreshalldescription" xml:space="preserve">
    <value>(Re-signs all macros based on the current user)</value>
  </data>
  <data name="macros.refreshsecurityparams.refreshalltooltip" xml:space="preserve">
    <value>If enabled, the macro re-signing process skips the signature integrity check, so you do not need to enter the old salt value. Check this option to re-sign all macros, including those that are unsigned or have invalid signatures.</value>
  </data>
  <data name="macros.refreshsecurityparams.usecurrentsalt" xml:space="preserve">
    <value>Use the current salt</value>
  </data>
  <data name="mem.facebook.enterapikey" xml:space="preserve">
    <value>Please enter an API key.</value>
  </data>
  <data name="mem.facebook.enterappsecret" xml:space="preserve">
    <value>Please enter an application secret.</value>
  </data>
  <data name="mem.facebook.enterpageid" xml:space="preserve">
    <value>Please enter a Facebook Page ID.</value>
  </data>
  <data name="objecttype.om_membershipsubscriber" xml:space="preserve">
    <value>Contact-subscriber relation</value>
  </data>
  <data name="settingskey.screenlockinterval.description" xml:space="preserve">
    <value>Time (in minutes) that has to pass before the screen is locked. This value has to be greater than 0 and lower than session timeout.</value>
  </data>
</root>